---
name: code
description: 計画に基づいてコードを記述（TDD推奨）
priority: high
suitable_for:
  scale: [small, medium, large]
  type: [feature, refactor, fix]
  understanding: "≥ 70%"
  urgency: [low, medium]
aliases: [implement, impl]
timeout: 120
context:
  files_changed: "any"
  lines_changed: "any"
  new_features: true
  breaking_changes: true
---

# /code - コード実装

## 目的

計画に基づいて実際のコード実装を実行します。

## 使用モード

- **スタンドアロン**: 特定の機能やバグ修正を実装
- **ワークフロー**: `/research` の結果に基づいてコーディングし、その後 `/test` へ進む

## 前提条件（ワークフローモード）

- `/think` でSOWが作成済み
- `/research` で技術調査が完了済み
- スタンドアロン使用の場合、実装の詳細が明確である必要があります

## 実装原則

### 適用される開発ルール

- [@~/.claude/rules/development/PROGRESSIVE_ENHANCEMENT.md] - UIのCSSファーストアプローチ
- [@~/.claude/rules/development/READABLE_CODE.md] - コードの可読性と明確性
- [@~/.claude/rules/development/CONTAINER_PRESENTATIONAL.md] - Reactコンポーネントパターン

### 原則の階層

**TDD/RGRCが主要な実装サイクルです**。このサイクル内で：

- **Red & Greenフェーズ**: 機能性のみに焦点を当てる
- **Refactorフェーズ**: SOLIDとDRY原則を適用
- **Commitフェーズ**: 安定した状態を保存

これにより、コードは最初に動作し（TDD）、その後クリーンで保守可能になります（SOLID/DRY）。

### 1. t_wadaのようなテスト駆動開発（TDD）

**目標**: 「動作するきれいなコード」 - Ron Jeffries

#### RGRCサイクル（Red-Green-Refactor-Commit）

1. **Red**: 最初に失敗するテストを書く
   - 正しい失敗を確認（間違った失敗 = 間違った理解）
   - テストは実装前の理解を文書化する

2. **Green**: テストを通すための最小限のコード
   - 「罪を犯してもよい」 - ここではクイック＆ダーティでOK
   - 余分な機能の追加を我慢
   - 完璧ではなく、動作させることに焦点を当てる

3. **Refactor**: 壊さずに改善
   - 重複を削除（DRY原則）
   - SOLID原則を適用
   - 意味のある抽象化を抽出
   - テストを常にグリーンに保つ

4. **Commit**: 進捗を保存（ユーザーが手動で実行）
   - コミット準備完了の安定した状態
   - ユーザーが手動でgitコマンドを実行

#### TDDのためのTodoWrite統合

各フェーズの開始時と完了時にステータスを更新：

- フェーズ開始時: ❌（進行中）にマーク
- フェーズ完了時: ✅（完了）にマーク
- 次のフェーズ: ❌（進行中）に切り替え

```
# シナリオ
1. ⏳ ユーザーは有効なメールアドレスで登録できる
2. ⏳ 無効なメールアドレスでは登録が失敗する

# 現在のRGRC（シナリオ1）
1.1 ✅ Red: ユーザー登録のテストを書く
1.2 ❌ Green: 最小限の登録ロジックを実装  ← アクティブ
1.3 ⏳ Refactor: バリデーションを抽出、命名を改善
1.4 ⏳ Commit: 進捗を保存
```

### 2. 実装中のSOLID原則

Refactorフェーズで適用：

- **SRP**: 各クラス/関数は変更理由を1つだけ持つ
- **OCP**: 既存コードを修正せずに機能を拡張
- **LSP**: 派生クラスは基底クラスと置換可能でなければならない
- **ISP**: クライアントは使用しないインターフェースに依存すべきでない
- **DIP**: 具体的な実装ではなく抽象に依存

### 3. DRY（Don't Repeat Yourself）原則

**「あらゆる知識は、単一の、曖昧でない、権威ある表現を持つべき」**

- 繰り返されるロジックを関数に抽出
- 繰り返される値に対して設定オブジェクトを作成
- 繰り返される構造にコンポジションを使用
- コピー＆ペーストプログラミングを避ける

### 4. 既存コードとの一貫性

- コーディング規約に従う
- 既存のパターンとライブラリを活用
- 命名規則の一貫性を維持

## 実装プロセス

### 1. 実装前の確認

- 実装計画の再確認
- 必要なファイルの特定
- 依存関係の確認

### 2. TDDによるコード実装

上記で定義したRGRCサイクルに従う：

- **Red**: 最初に失敗するテストを書く
- **Green**: テストを通すための最小限のコード
- **Refactor**: SOLIDとDRY原則を適用
- **Commit**: 安定した状態を保存

### 3. 品質チェック

**注**: プロジェクトにフックが設定されている場合、品質チェックは自動的に実行される場合があります。

**プロジェクト固有の品質コマンドを検出：**

- 最初にCLAUDE.mdまたは.claude/project.mdを確認
- package.json、Makefile、README.mdを調べる
- 一般的なパターン: lint、typecheck、test

**Bashツールを使用して品質チェックを実行：**

- 検出されたコマンドを実行（例：`npm run lint`、`npm run typecheck`）
- 出力をユーザーに表示
- 見つかったエラーや警告を修正
- すべてのチェックが通るまで再実行

**見つからない場合：** ユーザーに尋ね、CLAUDE.mdへの文書化を提案

### 4. 機能の確認

- 開発サーバーで確認
- エッジケースの検証
- パフォーマンスのチェック

## 主要な実践

- セキュリティのベストプラクティスに従う
- 適切なエラーハンドリングを実装
- アクセシビリティ要件を考慮

## 完了の定義

実装は以下の場合に完了とみなされます：

- 計画されたすべてのRGRCサイクルが完了
- すべてのテスト（新規および既存）が合格
- 品質チェックがクリーン：
  - lintエラー/警告なし（または許容可能なものが文書化済み）
  - 型エラーなし
  - コードがプロジェクト規約に従っている
- 変更が明確なメッセージでコミットされている
- TodoWriteタスクが完了としてマークされている

これらの基準のいずれかが満たされていない場合、作業を続けるか、進む前にブロッカーを文書化してください。

## 次のステップ

- **ワークフローモード**: 実装完了後、包括的なテストのため `/test` へ進む
- **スタンドアロンモード**: 必要に応じてテストまたは他の作業へ進む
