---
name: code
description: 計画に基づいてコードを記述（TDD推奨）
priority: high
suitable_for:
  scale: [small, medium, large]
  type: [feature, refactor, fix]
  understanding: "≥ 70%"
  urgency: [low, medium]
aliases: [implement, impl]
timeout: 120
allowed-tools: Bash(npm run:*), Bash(yarn:*), Bash(pnpm:*), Bash(make:*), Bash(git status:*), Edit, MultiEdit, Write, Read, Glob, Grep, LS, TodoWrite
context:
  files_changed: "dynamic"
  lines_changed: "tracked"
  test_status: "real-time"
  quality_checks: "discovered"
  confidence_level: "scored"
---

# /code - 動的品質保証付き高度な実装

## 目的

リアルタイムテストフィードバック、動的品質発見、信頼度スコア付き意思決定によるコード実装を実行します。

## 使用モード

- **スタンドアロン**: 特定の機能やバグ修正を実装
- **ワークフロー**: `/research` の結果に基づいてコーディングし、その後 `/test` へ進む

## 前提条件（ワークフローモード）

- `/think` でSOWが作成済み
- `/research` で技術調査が完了済み
- スタンドアロン使用の場合、実装の詳細が明確である必要があります

## 動的プロジェクトコンテキスト

### 現在の実装状態
Gitステータスを確認:
```bash
git status --porcelain 2>/dev/null | head -10
```

### 利用可能な品質コマンド
品質スクリプトを確認:
```bash
npm run 2>&1 | grep -E "lint|type|check|test|format"
```

### テストフレームワーク検出
package.jsonをチェック:
```bash
cat package.json 2>/dev/null | grep -E '"(jest|vitest|mocha|cypress|playwright)"'
```

### コード規約
設定ファイルを確認:
```bash
ls -la .eslintrc* .prettierrc* tsconfig.json 2>/dev/null
```

### 最近の関連変更
関連コミットを表示:
```bash
git log --oneline -5 --grep="[feature]" 2>/dev/null
```

## 実装原則

### 適用される開発ルール

- [@~/.claude/rules/development/PROGRESSIVE_ENHANCEMENT.md] - UIのCSSファーストアプローチ
- [@~/.claude/rules/development/READABLE_CODE.md] - コードの可読性と明確性
- [@~/.claude/rules/development/CONTAINER_PRESENTATIONAL.md] - Reactコンポーネントパターン

### 原則の階層

**TDD/RGRCが主要な実装サイクルです**。このサイクル内で：

- **Red & Greenフェーズ**: 機能性のみに焦点を当てる
- **Refactorフェーズ**: SOLIDとDRY原則を適用
- **Commitフェーズ**: 安定した状態を保存

これにより、コードは最初に動作し（TDD）、その後クリーンで保守可能になります（SOLID/DRY）。

### 1. t_wadaのようなテスト駆動開発（TDD）

**目標**: 「動作するきれいなコード」 - Ron Jeffries

#### リアルタイムフィードバック付き強化RGRCサイクル

1. **Redフェーズ** (信頼度目標: 0.9)
   テストを実行して失敗を確認:
   ```bash
   npm test -- --testNamePattern="[現在のテスト]" 2>&1 | grep -E "FAIL|PASS"
   ```
   - 明確な意図で失敗するテストを書く
   - 失敗理由が期待と一致することを確認
   - テストアサーションで理解を文書化
   - **終了条件**: 期待された理由でテストが失敗

2. **Greenフェーズ** (信頼度目標: 0.7)
   ウォッチモードでテストを実行:
   ```bash
   npm test -- --watch --testNamePattern="[現在のテスト]" 2>&1 &
   ```
   - パスするための最小実装
   - クイックソリューション許容
   - 形式より機能性に集中
   - **終了条件**: テストが一貫してパス

3. **Refactorフェーズ** (信頼度目標: 0.95)
   テスト結果を確認:
   ```bash
   npm test 2>&1 | tail -5 | grep -E "Passing|Failing"
   ```
   - SOLID原則を適用
   - 重複を削除（DRY）
   - 命名と構造を改善
   - 抽象化を抽出
   - **終了条件**: 全テスト緑、コードクリーン

4. **Commitフェーズ** (信頼度目標: 1.0)
   - 品質チェックがパス
   - カバレッジ維持/改善
   - 安定したコミット準備完了
   - ユーザーがgitコマンドを実行

#### 高度なTodoWrite統合

信頼度スコアリング付きリアルタイム追跡：

```markdown
# 実装: [機能名]
## シナリオ (総合信頼度: 0.85)
1. ⏳ 有効なメールでのユーザー登録 [C: 0.9]
2. ⏳ 無効なメールで登録失敗 [C: 0.8]
3. ⏳ 重複メール防止 [C: 0.85]

## 現在のRGRCサイクル - シナリオ1
### Redフェーズ (開始: 14:23)
1.1 ✅ 失敗するテストを書く [C: 0.95] ✓ 2分
1.2 ✅ 正しい失敗を確認 [C: 0.9] ✓ 30秒

### Greenフェーズ (アクティブ: 14:26) 
1.3 ❌ 登録ロジックを実装 [C: 0.7] ⏱️ 3分
1.4 ⏳ テストが一貫してパス [C: 保留]

### Refactorフェーズ (保留中)
1.5 ⏳ SOLID原則を適用 [C: 保留]
1.6 ⏳ バリデーションロジックを抽出 [C: 保留]

### 品質ゲート
- 🧪 テスト: 12/14 パス中
- 📊 カバレッジ: 78% (目標: 80%)
- 🔍 リント: 2つの警告
- 🔷 型: すべてパス
```

### 2. 実装中のSOLID原則

Refactorフェーズで適用：

- **SRP**: 各クラス/関数は変更理由を1つだけ持つ
- **OCP**: 既存コードを修正せずに機能を拡張
- **LSP**: 派生クラスは基底クラスと置換可能でなければならない
- **ISP**: クライアントは使用しないインターフェースに依存すべきでない
- **DIP**: 具体的な実装ではなく抽象に依存

### 3. DRY（Don't Repeat Yourself）原則

**「あらゆる知識は、単一の、曖昧でない、権威ある表現を持つべき」**

- 繰り返されるロジックを関数に抽出
- 繰り返される値に対して設定オブジェクトを作成
- 繰り返される構造にコンポジションを使用
- コピー＆ペーストプログラミングを避ける

### 4. 既存コードとの一貫性

- コーディング規約に従う
- 既存のパターンとライブラリを活用
- 命名規則の一貫性を維持

## 階層的実装プロセス

### フェーズ1: コンテキスト発見と計画
信頼度スコアリングで分析：
1. **コードコンテキスト**: 既存パターンを理解 (C: 0.0-1.0)
2. **依存関係**: 必要なライブラリが利用可能か確認
3. **規約**: プロジェクト標準を検出して従う
4. **テスト構造**: 従うべきテストパターンを特定

### フェーズ2: 並列品質実行
品質チェックを同時実行：
```typescript
// 逐次ではなく、これらを並列で実行
const qualityChecks = [
  Bash({ command: "npm run lint" }),
  Bash({ command: "npm run type-check" }),
  Bash({ command: "npm test -- --findRelatedTests" }),
  Bash({ command: "npm run format:check" })
];
```

### フェーズ3: 信頼度ベースの決定
証拠に基づいて実装選択を行う：
- **高信頼度 (>0.8)**: 実装を進める
- **中程度 (0.5-0.8)**: 防御的チェックを追加
- **低 (<0.5)**: 実装前に調査

### 2. TDDによるコード実装

上記で定義したRGRCサイクルに従う：

- **Red**: 最初に失敗するテストを書く
- **Green**: テストを通すための最小限のコード
- **Refactor**: SOLIDとDRY原則を適用
- **Commit**: 安定した状態を保存

### 3. 動的品質チェック

#### 自動発見
品質スクリプトを発見:
```bash
cat package.json 2>/dev/null | jq -r '.scripts | to_entries[] | select(.key | test("lint|type|check|test|format")) | .key' | head -10
```

#### 並列実行
```markdown
## 品質チェック結果
### リント (信頼度: 0.95)
```bash
npm run lint 2>&1 | tail -5
```
- ステータス: ✅ パス中
- 問題: 0エラー、2警告
- 時間: 1.2秒

### 型チェック (信頼度: 0.98)
```bash
npm run type-check 2>&1 | tail -5
```
- ステータス: ✅ すべての型が有効
- チェックファイル: 47
- 時間: 3.4秒

### テスト (信頼度: 0.92)
```bash
npm test -- --passWithNoTests 2>&1 | grep -E "Tests:|Snapshots:"
```
- ステータス: ✅ 45/45 パス中
- カバレッジ: 82%
- 時間: 8.7秒

### フォーマットチェック (信頼度: 0.90)
```bash
npm run format:check 2>&1 | tail -3
```
- ステータス: ⚠️ 3ファイルにフォーマットが必要
- 自動修正可能: はい
- 時間: 0.8秒
```

#### 品質スコア計算
```
総合品質スコア: (L*0.3 + T*0.3 + Test*0.3 + F*0.1) = 0.93
信頼度レベル: 高 - コミット準備完了
```

### 4. 機能の確認

- 開発サーバーで確認
- エッジケースの検証
- パフォーマンスのチェック

## 高度な機能

### リアルタイムテスト監視
開発中のテスト結果を監視：
```bash
npm test -- --watch --coverage 2>&1 &
```

### コード複雑度分析
実装中の複雑度を追跡：
```bash
npx complexity-report src/ 2>/dev/null | grep -E "Complexity|Maintainability"
```

### パフォーマンスプロファイリング
パフォーマンスクリティカルなコード用：
```bash
npm run profile 2>/dev/null
```

### セキュリティスキャン
自動脆弱性検出：
```bash
npm audit --production 2>&1 | grep -E "found|Severity"
```

## 実装パターン

### 信頼度によるパターン選択
```markdown
## 利用可能なパターン（コンテキストに基づいて選択）

### 高信頼度パターン (>0.9)
1. **ファクトリーパターン** - オブジェクト作成
   - いつ: 複数の類似オブジェクト
   - 信頼度: 0.95
   - 例: src/factories/

2. **リポジトリパターン** - データアクセス
   - いつ: データベース操作
   - 信頼度: 0.92
   - 例: src/repositories/

### 中信頼度パターン (0.7-0.9)
1. **オブザーバーパターン** - イベント処理
   - いつ: 疎結合が必要
   - 信頼度: 0.85
   - 考慮: 組み込みEventEmitter

### 実験的パターン (<0.7)
1. **新しいアーキテクチャパターン**
   - 信頼度: 0.6
   - 推奨: 最初にプロトタイプ
```

## リスク軽減

### 一般的な実装リスク
| リスク | 確率 | 影響 | 軽減策 | 信頼度 |
|-------|------|------|--------|--------|
| 既存テストの破壊 | 中 | 高 | 前後で完全スイート実行 | 0.95 |
| パフォーマンス劣化 | 低 | 高 | クリティカルパスをプロファイル | 0.88 |
| セキュリティ脆弱性 | 低 | 重大 | セキュリティスキャン+レビュー | 0.92 |
| 一貫性のないパターン | 中 | 中 | 既存例に従う | 0.90 |
| エッジケースの見逃し | 高 | 中 | 包括的テストケース | 0.85 |

## 信頼度メトリクス付き完了定義

すべてのメトリクスが達成された場合、実装完了：

```markdown
## 完了チェックリスト
### コア実装
- ✅ すべてのRGRCサイクル完了 [C: 0.95]
- ✅ 機能が仕様通り動作 [C: 0.93]
- ✅ エッジケース処理済み [C: 0.88]

### 品質メトリクス
- ✅ すべてのテストパス (47/47) [C: 1.0]
- ✅ カバレッジ ≥ 80% (現在: 82%) [C: 0.95]
- ✅ リントエラーゼロ [C: 0.98]
- ✅ 型エラーゼロ [C: 1.0]
- ⚠️ リント警告2つ (文書化済み) [C: 0.85]

### コード品質
- ✅ SOLID原則適用済み [C: 0.90]
- ✅ DRY - 重複なし [C: 0.92]
- ✅ 可読コード標準 [C: 0.88]
- ✅ コードベースと一貫性 [C: 0.94]

### ドキュメント
- ✅ 必要に応じてコードコメント [C: 0.85]
- ✅ 必要に応じてREADME更新 [C: 0.90]
- ✅ APIドキュメント最新 [C: 0.87]

### 総合信頼度: 0.92 (高)
ステータス: ✅ レビュー準備完了
```

重要メトリクスで信頼度 < 0.8 の場合、改善を続ける。

## 決定フレームワーク

### 実装信頼度が低い場合
```markdown
## 低信頼度検出 (< 0.7)
### 問題: [実装アプローチが不確実]

オプション:
1. **さらに調査** (/research)
   - 時間: +30分
   - 信頼度向上: +0.3
   
2. **最初にプロトタイプ**
   - 時間: +15分  
   - 信頼度向上: +0.2
   
3. **ドキュメント参照**
   - 時間: +10分
   - 信頼度向上: +0.15

推奨: 複雑な機能にはオプション1
```

### 品質ゲート失敗
```markdown
## 品質ゲート失敗
### 問題: カバレッジが80%未満に低下

現在: 78% (mainから-2%)
未カバー行: src/auth/validator.ts:45-52

アクション:
1. ❌ 未カバー行のテストを追加
2. ⏳ またはテスト不可能な理由を文書化
3. ⏳ または閾値を調整（非推奨）

解決せずに続行？ (y/N)
```

## 使用例

### 基本実装
```bash
/code "ユーザー認証を追加"
# 標準TDD実装
```

### 信頼度閾値付き
```bash
/code --confidence 0.9 "重要な支払いロジック"
# 続行前に90%の信頼度が必要
```

### 高速モード（一部チェックをスキップ）
```bash
/code --fast "シンプルなUI更新"
# 低リスク変更用の最小品質チェック
```

### 特定パターン付き
```bash
/code --pattern repository "データベースアクセスレイヤー"
# 実装にリポジトリパターンを使用
```

## 次のステップ

- **高信頼度 (>0.9)** → `/test`またはレビュー準備完了
- **中程度 (0.7-0.9)** → 追加テストを検討
- **低 (<0.7)** → `/research`または計画が必要
- **品質問題** → 続行前に修正
- **すべて緑** → PR/コミット準備完了
