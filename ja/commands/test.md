---
name: test
description: 実装コードの品質を包括的なテストで保証
priority: high
suitable_for:
  scale: [small, medium, large]
  type: [test]
  understanding: "≥ 70%"
  urgency: [low, medium]
aliases: []
timeout: 120
context:
  files_changed: "none"
  lines_changed: "0"
  new_features: false
  breaking_changes: false
---

# /test - テストと検証

## 目的

包括的なテストと検証を通じてコード品質を保証します。

## 使用方法

実装後にテストを実行して、機能を検証し、リグレッションをキャッチします。

## 実行戦略

### 1. テストコマンドの発見

- package.jsonでテストスクリプトを確認
- テスト設定ファイルを探す
- テストフレームワーク（Jest、Vitestなど）を特定

### 2. TodoWrite統合

テスト実行を追跡：

```md
# テスト: [機能/修正の説明]
1. ⏳ テストコマンドの発見
2. ⏳ ユニットテストの実行
3. ⏳ 統合テストの実行（利用可能な場合）
4. ⏳ 品質チェックの検証
5. ⏳ カバレッジのレビュー
```

### 3. テストタイプ

- **ユニットテスト**: 個々のコンポーネント/関数
- **統合テスト**: コンポーネント間の相互作用
- **E2Eテスト**: 完全なユーザーワークフロー（利用可能な場合）

### 4. ブラウザテスト（UI変更時）

UIが影響を受ける場合、Playwright MCPツールを使用して：

- 視覚的な外観を検証
- インタラクティブ機能をテスト
- レスポンシブデザインをチェック
- アクセシビリティを検証

### 5. 品質チェック

- リンターを実行（利用可能な場合）
- 型チェックを実行（TypeScriptプロジェクトの場合）
- テストカバレッジメトリクスをチェック
- リグレッションが導入されていないことを確認

## テスト実行プロセス

1. **発見フェーズ**
   - 利用可能なテストコマンドを見つける
   - テストファイルパターンを特定
   - CI/CD設定を確認

2. **実行フェーズ**
   - 適切な順序でテストを実行
   - 結果をキャプチャして分析
   - 失敗を特定

3. **解決フェーズ**
   - テストが失敗した場合 → 根本原因を調査
   - 修正を適用 → テストを再実行
   - すべてパスするまで繰り返す

## 出力フォーマット

```markdown
## テスト結果
- 実行テスト数: [カウント]
- 成功: [カウント]
- 失敗: [カウント]
- カバレッジ: [パーセンテージ]

## 失敗したテスト（該当する場合）
[理由付きの失敗リスト]

## 次のアクション
[必要な優先順位付けされた修正]
```

## 使用する場合

- 新機能実装後
- バグ修正後
- プルリクエスト作成前
- コードリファクタリング時

## 使用しない場合

- アクティブな開発中（中断が多すぎる）
- ドキュメント変更のみの場合
- テストインフラが存在しない場合

## 使用例

```md
/test "認証変更のテストを実行"
/test "支払い処理の修正を検証"
/test "リリース前の完全なテストスイート"
```

## ヒント

1. **ユニットテストから始める** - 最速のフィードバック
2. **失敗をすぐに修正** - 蓄積させない
3. **カバレッジの傾向を監視** - 改善を目指す
4. **適切なテストレベルを使用** - すべてにE2Eは不要

## 次のステップ

- テスト失敗 → `/fix` で問題に対処
- すべて成功 → PRまたはデプロイの準備完了
- 低カバレッジ → 追加のテストを作成
